
#pragma once

#include <future>

namespace rmngr
{

template < typename NullaryCallable >
class DelayedFunctor
{
    using Result = typename std::result_of<NullaryCallable>::type;
public:
    DelayedFunctor(NullaryCallable && impl)
        : impl(std::move(impl)) {}

    void operator() (void)
    {
        set_promise(this->result, this->impl);
    }

    std::future<Result> get_future(void)
    {
        return this->result.get_future();
    }

private:
    NullaryCallable impl;
    std::promise<Result> result;

    template <typename T, typename F>
    static void set_promise (std::promise<T>& p, F& func)
    {
        p.set_value(func());
    }

    template <typename F>
    static void set_promise (std::promise<void>& p, F& func)
    {
        func();
        p.set_value();
    }
}; // class DelayedFunctor

} // namespace rmngr

